class Constants{static COMMENT_CHAR="#";static TAB_SPACES=4;static TAB="\t";static SPACE=" ";static SEP_NODE=":";static ENCODING="UTF-8";static NAMESPACE="Namespace"}let ParseException$1=class extends Error{constructor(e,t){super(`Line ${t}: ${e}`),this.line=t,this.name="ParseException"}};const EMPTY_LINE=/^\s*$/,COMMENT_LINE=/^\s*#.*$/;class LineIndent{static UTF8_BOM="\ufeff";constructor(e,t){this.indentLevel=e,this.lineWithoutIndent=t}toString(){return"["+this.indentLevel+"]: "+this.lineWithoutIndent}static parseLine(e,t,a,s){if(!t&&(EMPTY_LINE.test(e)||COMMENT_LINE.test(e)))return null;let i=0,n=0,r=0;for(;r<e.length;){let s=e.charAt(r);if(s===Constants.SPACE)n++,n===Constants.TAB_SPACES&&(i++,n=0);else{if(s!==Constants.TAB)break;i++,n=0}if(r++,t&&i>=a)break}if(0!==n)throw new ParseException$1("Invalid number spaces",s);if(t&&i<a){if(EMPTY_LINE.test(e))return new LineIndent(a,"");if(COMMENT_LINE.test(e))return null}return new LineIndent(i,e.substring(r))}static removeUTF8BOM(e){return e.startsWith(LineIndent.UTF8_BOM)&&(e=e.substring(1)),e}}class LineSplitter{constructor(e,t,a){this.prefix=e,this.centralText=t,this.suffix=a}getPrefix(){return this.prefix}getCentralText(){return this.centralText}getSuffix(){return this.suffix}static split(e){let t,a,s;const i=e.match(/(\(([^)]*)\))?(.*?)(\(([^)]*)\))?$/);return i?(t=i[2]?i[2].trim():null,a=i[3]?i[3].trim():null,s=i[5]?i[5].trim():null):(a=e.trim(),t=null,s=null),a&&0===a.length&&(a=null),new LineSplitter(t,a,s)}}class NamespaceChild{constructor(){this.name="",this.namespace="",this.num=""}getName(){return this.name}setName(e){this.name=e}getNamespace(){return this.namespace}setNamespace(e){this.namespace=e}getNum(){return this.num}setNum(e){this.num=e}toString(){let e=`NamespaceChild [name=${this.name}, num=${this.num}`;return this.namespace&&(e+=`, namespace=${this.namespace}`),e+="]",e}}class NamespaceNode{constructor(){this.name="",this.type="",this.childs=new Map,this.values=new Set}getValues(){return this.values}setValues(e){this.values=e}getName(){return this.name}setName(e){this.name=e}getChilds(){return this.childs}setChilds(e){this.childs=e}setChild(e,t){this.childs.set(e,t)}getType(){return this.type}setType(e){this.type=e}toString(){return`NamespaceNode [name=${this.name}, type=${this.type}, values=${Array.from(this.values)}, childs=${Array.from(this.childs.entries()).map((([e,t])=>`${e}=${t.toString()}`))}]`}}class Namespace{constructor(){this.nodes=new Map,this.name=""}getNodes(){return this.nodes}getNode(e){return this.nodes.get(e)}setNode(e,t){this.nodes.set(e,t)}setNodes(e){this.nodes=new Map(Object.entries(e))}getName(){return this.name}setName(e){this.name=e}toString(){let e=`Namespace: ${this.name}\n`;for(const[t,a]of this.nodes.entries()){e+=`NODE: ${a.getName()}, type: ${a.getType()} -> ${Array.from(a.getValues()).join(", ")}\n`;for(const[t,s]of a.getChilds().entries())e+=`\tChild: ${s.toString()}\n`}return e}}const NamespaceType={TEXT:"TEXT",STRING:"STRING",NUMBER:"NUMBER",BOOLEAN:"BOOLEAN",REGEX:"REGEX",ENUM:"ENUM",DATE:"DATE",TIMESTAMP:"TIMESTAMP",EMAIL:"EMAIL",URL:"URL",HEXADECIMAL:"HEXADECIMAL",BASE64:"BASE64",EMPTY:"EMPTY",INTEGER:"INTEGER",NATURAL:"NATURAL",getDefault:getDefault,isValidType:isValidType,isMultiline:isMultiline,isValuesType:isValuesType,isValidNamespace:isValidNamespace,isValidCount:isValidCount},MULTILINE_TYPES=new Set([NamespaceType.TEXT,NamespaceType.BASE64,NamespaceType.HEXADECIMAL]),SINGLELINE_TYPES=new Set([NamespaceType.STRING,NamespaceType.NUMBER,NamespaceType.BOOLEAN,NamespaceType.REGEX,NamespaceType.ENUM,NamespaceType.DATE,NamespaceType.TIMESTAMP,NamespaceType.EMAIL,NamespaceType.URL,NamespaceType.EMPTY,NamespaceType.INTEGER,NamespaceType.NATURAL]),ALL_TYPES=new Set([...SINGLELINE_TYPES,...MULTILINE_TYPES]),VALUES_TYPES=new Set([NamespaceType.ENUM,NamespaceType.REGEX]),ALLOWED_COUNT=new Set(["*","+","?"]),COUNT=/^\d+(\+|-)?$/;function getDefault(){return NamespaceType.STRING}function isValidType(e){return ALL_TYPES.has(e)}function isMultiline(e){return MULTILINE_TYPES.has(e)}function isValuesType(e){return VALUES_TYPES.has(e)}function isValidNamespace(e){try{return!!e.endsWith(".stxt")&&(new URL("https://"+e),!0)}catch(e){return!1}}function isValidCount(e){return ALLOWED_COUNT.has(e)||validateValue(COUNT,e)}function validateValue(e,t){return e.test(t)}class NodeLine{constructor(e,t,a,s){this.lineCreation=e,this.levelCreation=t,this.value=a,this.explicit=s}getValue(){return this.value}getLineCreation(){return this.lineCreation}getLevelCreation(){return this.levelCreation}isExplicit(){return this.explicit}isImplicit(){return!this.explicit}toString(){return`NodeValue [value=${this.value}, line=${this.lineCreation}, ${this.explicit?"explicit":"implicit"}]`}}class Node{constructor(e,t,a,s){this.levelCreation=t,this.lineCreation=e,this.name=a,this.value=s,this.lines=[],this.childs=[],this.metadata={},this.multiline=!1}setMultiline(e){this.multiline=e}isMultiline(){return this.multiline}getValue(){return this.value}getMetadata(e){return this.metadata[e]}setMetadata(e,t){this.metadata[e]=t}getChilds(){return this.childs}addChild(e){this.childs.push(e)}getName(){return this.name}setName(e){this.name=e}getLineCreation(){return this.lineCreation}addLine(e){this.lines.push(e)}getValues(){return this.lines}getText(){let e="";this.value&&(e+=this.value+"\n");for(const t of this.lines)e+=t.getValue()+"\n";return e.replace(/(\s*\r?\n)+$/,"")}getChildsByName(e){return this.childs.filter((t=>t.getName()===e))}getChild(e){const t=this.getChildsByName(e);if(t.length>1)throw new Error("More than 1 child. Use getChilds");return 0===t.length?null:t[0]}getChildValue(e){const t=this.getChildsByName(e);if(t.length>1)throw new Error("More than 1 child. Use getChilds");return 0===t.length?null:t[0].getValue()}toString(e=0){let t="";for(let a=0;a<e;a++)t+="    ";if(t+=`<${this.name}> (line:${this.lineCreation}) ${JSON.stringify(this.metadata)}: '${this.getValueShort()}', lines = ${this.lines}`,t+="\n",this.childs&&this.childs.length>0)for(const a of this.childs)t+=a.toString(e+1),t+="\n";return t.replace(/\n\n/g,"\n")}getValueShort(){return null==this.value?"<NULL>":this.value}getLevelCreation(){return this.levelCreation}}class NamespaceRawTransformer{static async transformRawNode(e){let t=new Namespace,a=e.getName();const s=LineSplitter.split(a);if(a=s.centralText,!Constants.NAMESPACE.toLowerCase()===a.toLowerCase())throw new ParseException$1("Line not valid: "+a,e.getLineCreation());if(null!==s.suffix)throw new ParseException$1("Namespace name not allowed in namespace definition: "+s.suffix,e.getLineCreation());if(null!==s.prefix)throw new ParseException$1("Line not valid with prefix",e.getLineCreation());this.validateNamespaceFormat(e.getValue(),e.getLineCreation()),t.setName(e.getValue());for(const a of e.getChilds())await this.updateNamespace(a,t);return t}static async updateNamespace(e,t){const a=e.getName();let s=null;if(null!==e.getValue()){s=LineSplitter.split(e.getValue()).centralText}let i=t.getNode(a);if(i){if(null!==s)throw new ParseException$1("Type should be defined the first time only",e.getLineCreation())}else if(i=new NamespaceNode,i.setName(a),i.setType(s),t.setNode(a,i),null!==s&&this.validateType(s,e),null===s&&i.setType(NamespaceType.getDefault()),e.getValues().length>0){const t=new Set;for(const a of e.getValues())t.add(a.getValue().trim());if(!NamespaceType.isValuesType(s))throw new ParseException$1("Type not allow values: "+s,e.getLineCreation());i.setValues(t)}const n=e.getChilds();if(null!==n){if(NamespaceType.isMultiline(s)&&n.length>0)throw new ParseException$1("Type "+s+" not allows childs",n[0].getLineCreation());for(const e of n){const a=e.getName();if(""!==a){const s=new NamespaceChild;i.getChilds().set(a,s),s.setName(a);const n=e.getValue();if(null!==n){const t=LineSplitter.split(n),a=t.prefix;if(null===a)throw new ParseException$1("Count is required",e.getLineCreation());if(!NamespaceType.isValidCount(a))throw new ParseException$1("Count is not valid: "+a,e.getLineCreation());const i=t.suffix;if(s.setNum(null!==a?a:"*"),s.setNamespace(i),null!==i){if(!isValidNamespace(i))throw new ParseException$1("Namespace not valid: "+i,e.getLineCreation());if(null!==t.centralText)throw new ParseException$1("Namespace not allow type: "+i,e.getLineCreation())}}null===s.getNamespace()&&await this.updateNamespace(e,t)}}}}static validateNamespaceFormat(e,t){if(!isValidNamespace(e))throw new ParseException$1("Namespace not valid: "+e,t)}static validateType(e,t){if(!isValidType(e))throw new ParseException$1("Type not valid: "+e,t.getLineCreation())}}class Processor{async processNodeOnCreation(e){throw new ParseException$1("Method 'processNodeOnCreation' must be implemented.")}async processNodeOnCompletion(e){throw new ParseException$1("Method 'processNodeOnCompletion' must be implemented.")}async processBeforeAdd(e,t){throw new ParseException$1("Method 'processBeforeAdd' must be implemented.")}async processAfterAdd(e,t){throw new ParseException$1("Method 'processAfterAdd' must be implemented.")}}class Parser{constructor(){this.debug=!1,this.nodeProcessors=[],this.document=null,this.stack=[],this.currentRoot=null,this.lineNumber=0,this.currentLevel=0}addNodeProcessor(e){this.nodeProcessors.push(e)}async parse(e){this.document=[],this.stack=[],this.currentRoot=null,this.lineNumber=0,this.currentLevel=0;const t=(e=LineIndent.removeUTF8BOM(e)).split("\n");for(let e of t)this.lineNumber++,e=e.replace(/\r/g,""),await this.processLine(e);return null!==this.currentRoot&&(await this.processCompletion(this.currentRoot),this.document.push(this.currentRoot)),this.document}async processLine(e){const t=this.stack.length>0?this.stack[this.stack.length-1]:null,a=null!==t&&t.isMultiline(),s=LineIndent.parseLine(e,a,this.stack.length,this.lineNumber);if(null===s)return;if(this.showLine(e,s),a&&s.indentLevel>=this.stack.length)return void this.addMultilineValue(t,s.lineWithoutIndent,!1);if(s.indentLevel>this.currentLevel+1)throw new ParseException$1("Level of indent incorrect: "+s.indentLevel,this.lineNumber);this.currentLevel=s.indentLevel;const i=await this.createNode(s);if(null!==i.getName()||null===t){if(await this.processCreation(i),0===this.currentLevel)null!==this.currentRoot&&(await this.processCompletion(this.currentRoot),this.document.push(this.currentRoot)),this.currentRoot=i,this.stack=[],this.stack.push(this.currentRoot);else{for(;this.stack.length>this.currentLevel;){const e=this.stack.pop();await this.processCompletion(e)}const e=this.stack[this.stack.length-1];await this.processBeforeAddNode(e,i),e.addChild(i),await this.processAfterAddNode(e,i),this.stack.push(i)}this.showCurrentRoot()}else this.addMultilineValue(t,i.getValue(),!0)}addMultilineValue(e,t,a){e.addLine(new NodeLine(this.lineNumber,this.currentLevel,t,a)),this.showCurrentRoot()}async createNode(e){const t=e.lineWithoutIndent;let a=t,s=null;const i=t.indexOf(":");if(-1===i)throw new ParseException$1("Line not valid: "+t,this.lineNumber);return a=t.substring(0,i).trim(),s=t.substring(i+1),""===a?a=null:(s=s.trim(),""===s&&(s=null)),new Node(this.lineNumber,this.currentLevel,null===a?a:a.toLowerCase(),s)}async processCreation(e){for(const t of this.nodeProcessors)await t.processNodeOnCreation(e)}async processCompletion(e){for(const t of this.nodeProcessors)await t.processNodeOnCompletion(e)}async processBeforeAddNode(e,t){for(const a of this.nodeProcessors)await a.processBeforeAdd(e,t)}async processAfterAddNode(e,t){for(const a of this.nodeProcessors)await a.processAfterAdd(e,t)}showCurrentRoot(){this.debug&&console.log("\n"+this.currentRoot)}showLine(e,t){this.debug&&(console.log("***********************************************************************************"),console.log("Line: '"+e+"'"),console.log("Line "+this.lineNumber+": "+t))}}async function getUrlContent(e){const t=new Headers({"Accept-Language":"en-US,en;q=0.5",Accept:"text/html"}),a=await fetch(e,{method:"GET",headers:t});if(!a.ok)throw new Error(`HTTP error! status: ${a.status}`);return await a.text()}function uniform(e){return e.trim().toLowerCase()}function cleanupString(e){return e.replace(/[\r\n\t]+|\s+/g,"")}class NamespaceRetriever{constructor(e=!1){this.CACHE=new Map,this.allowInternet=e}addGrammarDefinition(e,t=null){return new Promise((async(a,s)=>{try{const i=new Parser,n=await i.parse(e),r=[];for(const e of n)r.push(await NamespaceRawTransformer.transformRawNode(e));null===t||1===r.length&&r[0].getName()===t||s(new ParseException(`Namespace is ${r[0].getName()}, expected: ${t}`,0));for(const e of r){const t=e.getName();this.CACHE.has(t)&&s(new ParseException(`Namespace already exist: ${t}`,0)),this.CACHE.set(t,e)}a()}catch(e){s(e)}}))}getAllNamespaces(){return new Set(this.CACHE.keys())}async getNameSpace(e){if(this.CACHE.has(e))return this.CACHE.get(e);if(this.allowInternet)try{const t=new URL(`https://${e}`),a=await getUrlContent(t);return await this.addGrammarDefinition(a,e),this.CACHE.get(e)}catch(e){throw new Error(`Error retrieving namespace: ${e.message}`)}return this.CACHE.get(e)}}const P_BOOLEAN=/^(true|false)$/,P_HEXADECIMAL=/^#?([A-Fa-f0-9]|\s)+$/,P_INTEGER=/^(\-|\+)?\d+$/,P_NATURAL=/^\d+$/,P_NUMBER=/^(\-|\+)?\d+(\.\d+(e(\-|\+)?\d+)?)?$/,P_DATE=/^\d{4}-\d{2}-\d{2}$/,ISO_8601_PATTERN="^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[+-]\\d{2}:\\d{2})?$",P_TIMESTAMP=new RegExp(ISO_8601_PATTERN),EMAIL_PATTERN="^(?=.{1,256})(?=.{1,64}@.{1,255}$)(?=.{1,64}@.{1,63}\\..{1,63}$)[A-Za-z0-9!#$%&'*+/=?^_`{|}~.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$",P_EMAIL=new RegExp(EMAIL_PATTERN);class NamespaceValidator{static async validateValue(e,t){const a=e.getType();if(NamespaceType.BASE64===a)return this.validateBase64(t);if(NamespaceType.BOOLEAN===a)return this.validateBoolean(t);if(NamespaceType.HEXADECIMAL===a)return this.validateHexadecimal(t);if(NamespaceType.INTEGER===a)return this.validateInteger(t);if(NamespaceType.NATURAL===a)return this.validateNatural(t);if(NamespaceType.URL===a)return this.validateUrl(t);if(NamespaceType.NUMBER===a)return this.validateNumber(t);if(NamespaceType.TEXT===a)return this.validateText(t);if(NamespaceType.STRING===a)return this.validateText(t);if(NamespaceType.DATE===a)return this.validateDate(t);if(NamespaceType.EMAIL===a)return this.validateEmail(t);if(NamespaceType.EMPTY===a)return this.validateEmpty(t);if(NamespaceType.TIMESTAMP===a)return this.validateTimestamp(t);if(NamespaceType.ENUM===a)return this.validateEnum(t,e.getValues());if(NamespaceType.REGEX===a)return this.validateRegex(t,e.getValues());throw new ParseException$1("Node type not supported: "+a,t.getLineCreation())}static async validateCount(e,t){const a=new Map;for(const e of t.getChilds()){const t=e.getName();a.set(t,(a.get(t)||0)+1)}for(const s of e.getChilds().values())this.verifyCount(s,a.get(s.getName())||0,t)}static verifyCount(e,t,a){const s=e.getNum();if("*"!=s)if("?"==s){if(t>1)throw new ParseException$1(`Node '${a.getName()}' can have only 1 child of name '${e.getName()}' and have ${t}`,a.getLineCreation())}else if("+"==s){if(0==t)throw new ParseException$1(`Node '${a.getName()}' should have at least 1 child of name '${e.getName()}'`,a.getLineCreation())}else if(s.endsWith("+")){const i=parseInt(s.slice(0,-1),10);if(t<i)throw new ParseException$1(`Node '${a.getName()}' should have at least ${i} childs of name '${e.getName()}', and have ${t}`,a.getLineCreation())}else if(s.endsWith("-")){const i=parseInt(s.slice(0,-1),10);if(t>i)throw new ParseException$1(`Node '${a.getName()}' should have maximum of ${i} childs of name '${e.getName()}', and have ${t}`,a.getLineCreation())}else{const i=parseInt(s,10);if(i!==t)throw new ParseException$1(`Node '${a.getName()}' should have ${i} of child of name '${e.getName()}', and have ${t}`,a.getLineCreation())}}static validateBoolean(e){this.validateValueWithPattern(e,P_BOOLEAN,"Invalid boolean")}static validateDate(e){this.validateValueWithPattern(e,P_DATE,"Invalid date")}static validateTimestamp(e){this.validateValueWithPattern(e,P_TIMESTAMP,"Invalid timestamp")}static validateEmail(e){this.validateValueWithPattern(e,P_EMAIL,"Invalid email")}static validateInteger(e){this.validateValueWithPattern(e,P_INTEGER,"Invalid integer")}static validateNatural(e){this.validateValueWithPattern(e,P_NATURAL,"Invalid natural")}static validateNumber(e){this.validateValueWithPattern(e,P_NUMBER,"Invalid number")}static validateEmpty(e){if(null!==e.getValue()||null!==e.getValues()&&e.getValues().length>0)throw new ParseException$1(`Node '${e.getName()}' has to be empty`,e.getLineCreation())}static validateBase64(e){try{atob(cleanupString(e.getText()))}catch(t){throw new ParseException$1(`Node '${e.getName()}' Invalid Base64`,e.getLineCreation())}}static validateHexadecimal(e){const t=cleanupString(e.getText());if(!P_HEXADECIMAL.exec(t))throw new ParseException$1(`Node '${e.getName()}' Invalid hexadecimal`,e.getLineCreation())}static validateText(e){}static validateEnum(e,t){if(!t.has(e.getValue()))throw new ParseException$1(`Node '${e.getName()}' has value not allowed: ${e.getValue()}`,e.getLineCreation())}static validateRegex(e,t){for(const a of t){if(new RegExp(a).test(e.getValue()))return}throw new ParseException$1(`Node '${e.getName()}' has value not allowed: ${e.getValue()}`,e.getLineCreation())}static validateUrl(e){if(!this.isValidURL(e.getValue()))throw new ParseException$1(`Invalid URL: ${e.getValue()}`,e.getLineCreation())}static isValidURL(e){try{return new URL(e),!0}catch(e){return!1}}static validateValueWithPattern(e,t,a){if(!t.exec(e.getValue()))throw new ParseException$1(`${e.getName()}: ${a} (${e.getValue()})`,e.getLineCreation())}}class RawCustomProcessor extends Processor{constructor(){super(),this.multilineNodes=new Set,this.allowedNames=new Set}setMultilineNodes(e){this.multilineNodes=e}setAllowedNames(e){this.allowedNames=e}async processNodeOnCreation(e){if(this.multilineNodes&&this.multilineNodes.has(e.getName())&&e.setMultiline(!0),this.allowedNames&&!this.allowedNames.has(e.getName()))throw new ParseException$1("Node name not allowed: "+e.getName(),e.getLineCreation())}async processNodeOnCompletion(e){}async processBeforeAdd(e,t){}async processAfterAdd(e,t){}}const NAMESPACE="namespace";class STXTProcessor{constructor(e){this.namespaceRetriever=e,this.currentDocRaw=!1}async processNodeOnCreation(e){0===e.getLevelCreation()&&await this.updateMainNamespace(e)}async processNodeOnCompletion(e){if(this.currentDocRaw)return;const t=e.getMetadata(NAMESPACE),a=(await this.namespaceRetriever.getNameSpace(t)).getNode(e.getName());await NamespaceValidator.validateCount(a,e),await NamespaceValidator.validateValue(a,e),this.validateNotImplicitMultiline(e)}async processBeforeAdd(e,t){if(this.currentDocRaw)return;const a=e.getMetadata(NAMESPACE),s=e.getName(),i=(await this.namespaceRetriever.getNameSpace(a)).getNode(s).getChilds().get(t.getName());if(!i)throw new ParseException$1("Name not valid: "+t.getName(),t.getLineCreation());let n=i.getNamespace();n||(n=a),t.setMetadata(NAMESPACE,n);const r=await this.namespaceRetriever.getNameSpace(n);if(!r)throw new ParseException$1("Not found namespace "+n,t.getLineCreation());const o=r.getNode(t.getName());if(!o)throw new ParseException$1("Not found "+t.getName()+" in namespace "+n,t.getLineCreation());t.setMultiline(NamespaceType.isMultiline(o.getType()))}async processAfterAdd(e,t){}async updateMainNamespace(e){const t=LineSplitter.split(e.getName()),a=t.centralText,s=t.suffix,i=t.prefix;if(this.currentDocRaw=null===s,this.currentDocRaw)return;if(null!==i)throw new ParseException$1("Prefix not allowed in node name: "+i,e.getLineCreation());const n=await this.namespaceRetriever.getNameSpace(s);if(!n)throw new ParseException$1("Namespace unknown: "+s,e.getLineCreation());const r=n.getNode(a);if(!r)throw new ParseException$1("Name "+a+" not found in namespace "+s,e.getLineCreation());e.setName(a),e.setMetadata(NAMESPACE,s),await NamespaceValidator.validateValue(r,e)}validateNotImplicitMultiline(e){if(null!==e.getValues())for(const t of e.getValues())if(t.isExplicit())throw new ParseException$1("No allowed explicit multilines in NS documents",t.getLineCreation())}}class STXTParser extends Parser{constructor(e){super(),this.addNodeProcessor(new STXTProcessor(e))}}export{Constants,LineIndent,LineSplitter,Namespace,NamespaceChild,NamespaceNode,NamespaceRawTransformer,NamespaceRetriever,NamespaceType,NamespaceValidator,Node,NodeLine,ParseException$1 as ParseException,Parser,Processor,RawCustomProcessor,STXTParser,STXTProcessor,cleanupString,getDefault,getUrlContent,isMultiline,isValidCount,isValidNamespace,isValidType,isValuesType,uniform};